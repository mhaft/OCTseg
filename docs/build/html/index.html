
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Welcome to OCTseg’s documentation! &#8212; OCTseg  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="welcome-to-octseg-s-documentation">
<h1>Welcome to OCTseg’s documentation!<a class="headerlink" href="#welcome-to-octseg-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>
<div class="section" id="training-and-testing">
<h2>Training and Testing<a class="headerlink" href="#training-and-testing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="train.main">
<code class="sig-prename descclassname">train.</code><code class="sig-name descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#train.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Train or test a U-Net model to analyze OCT images.</p>
<p class="rubric">Notes</p>
<p><strong>All arguments are bash arguments</strong>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>exp_def</strong> – experiment definition</p></li>
<li><p><strong>models_path</strong> – path for saving models</p></li>
<li><p><strong>lr</strong> – learning rate</p></li>
<li><p><strong>lr_decay</strong> – learning rate step for decay</p></li>
<li><p><strong>data_pat</strong> – data folder path</p></li>
<li><p><strong>nEpoch</strong> – number of epochs</p></li>
<li><p><strong>nBatch</strong> – batch size</p></li>
<li><p><strong>outCh</strong> – size of output channel</p></li>
<li><p><strong>inCh</strong> – size of input channel</p></li>
<li><p><strong>nZ</strong> – size of input depth</p></li>
<li><p><strong>w</strong> – size of input width (number of columns)</p></li>
<li><p><strong>l</strong> – size of input Length (number of rows)</p></li>
<li><p><strong>loss_w</strong> – loss wights</p></li>
<li><p><strong>isAug</strong> – Is data augmentation</p></li>
<li><p><strong>isCarts</strong> – whether images should be converted into Cartesian</p></li>
<li><p><strong>isTest</strong> – Is test run instead of train</p></li>
<li><p><strong>testEpoch</strong> – epoch of the saved model for testing</p></li>
<li><p><strong>saveEpoch</strong> – epoch interval to save the model</p></li>
<li><p><strong>epochSize</strong> – number of samples per epoch</p></li>
<li><p><strong>nFeature</strong> – number of features in the first layer</p></li>
<li><p><strong>nLayer</strong> – number of layers in the U-Nnet model</p></li>
<li><p><strong>gpu_id</strong> – ID of GPUs to be used</p></li>
<li><p><strong>optimizer</strong> – keras optimizer. see <code class="xref py py-meth docutils literal notranslate"><span class="pre">keras.optimizers()</span></code></p></li>
<li><p><strong>Also</strong> (<em>See</em>) – <ul>
<li><p><a class="reference internal" href="#unet.unet.unet_model" title="unet.unet.unet_model"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unet.unet.unet_model()</span></code></a></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">unet.loss.multi_loss_fun()</span></code></p></li>
<li><p><a class="reference internal" href="#util.load_data.load_train_data" title="util.load_data.load_train_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">util.load_data.load_train_data()</span></code></a></p></li>
<li><p><a class="reference internal" href="#util.load_batch.load_batch_parallel" title="util.load_batch.load_batch_parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">util.load_batch.load_batch_parallel()</span></code></a></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">keras.utils.multi_gpu_model()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">keras.optimizers()</span></code></p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="u-net">
<h2>U-Net<a class="headerlink" href="#u-net" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-unet.loss">
<span id="loss"></span><h3>loss<a class="headerlink" href="#module-unet.loss" title="Permalink to this headline">¶</a></h3>
<p>CNN related loss functions</p>
<dl class="function">
<dt id="unet.loss.boundary_transition_loss">
<code class="sig-prename descclassname">unet.loss.</code><code class="sig-name descname">boundary_transition_loss</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unet.loss.boundary_transition_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare the number of boundaries along the columns.</p>
</dd></dl>

<dl class="function">
<dt id="unet.loss.dice_loss">
<code class="sig-prename descclassname">unet.loss.</code><code class="sig-name descname">dice_loss</code><span class="sig-paren">(</span><em class="sig-param">label</em>, <em class="sig-param">target</em><span class="sig-paren">)</span><a class="headerlink" href="#unet.loss.dice_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Soft Dice coefficient loss</p>
<p>TP, FP, and FN are true positive, false positive, and false negative.</p>
<div class="math notranslate nohighlight">
\[\begin{split}dice  &amp;=  \frac{2 \times TP}{ 2 \times TP + FN + FP} \\
dice  &amp;=  \frac{2 \times TP}{(TP + FN) + (TP + FP)}\end{split}\]</div>
<p>objective is to maximize the dice, thus the loss is negate of dice for numerical stability (+1 in denominator)
and fixing the loss range (+1 in numerator and +1 to the negated dice).</p>
<p>The final Dice loss is formulated as</p>
<div class="math notranslate nohighlight">
\[dice \ loss = 1 - \frac{2 \times TP + 1}{(TP + FN) + (TP + FP ) + 1}\]</div>
<p>it is soft as each components of the confusion matrix (TP, FP, and FN) are estimated by dot product of
probability instead of hard classification</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> – 4D or 5D label tensor</p></li>
<li><p><strong>target</strong> – 4D or 5D target tensor</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dice loss</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="unet.loss.mask_boundary_neighborhood">
<code class="sig-prename descclassname">unet.loss.</code><code class="sig-name descname">mask_boundary_neighborhood</code><span class="sig-paren">(</span><em class="sig-param">label</em>, <em class="sig-param">r=5</em>, <em class="sig-param">numClass=2</em><span class="sig-paren">)</span><a class="headerlink" href="#unet.loss.mask_boundary_neighborhood" title="Permalink to this definition">¶</a></dt>
<dd><p>mask the neighborhood of the boundary between foreground and background.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> – input <a href="#id7"><span class="problematic" id="id8">label_</span></a></p></li>
<li><p><strong>r</strong> – neighborhood radius</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>mask</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#unet.loss.weighted_cross_entropy_with_boundary" title="unet.loss.weighted_cross_entropy_with_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">weighted_cross_entropy_with_boundary()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="unet.loss.multi_loss">
<code class="sig-prename descclassname">unet.loss.</code><code class="sig-name descname">multi_loss</code><span class="sig-paren">(</span><em class="sig-param">loss_weight</em>, <em class="sig-param">numClass</em><span class="sig-paren">)</span><a class="headerlink" href="#unet.loss.multi_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Semantic loss function based on the weighted cross entropy and dice and wighted by the loss weights in the input
argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loss_weight</strong> – a list with three weights for weighted cross entropy, foreground, and dice losses, respectively.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>function, which similar to <code class="xref py py-meth docutils literal notranslate"><span class="pre">weighted_cross_entropy()</span></code> and <a class="reference internal" href="#unet.loss.dice_loss" title="unet.loss.dice_loss"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dice_loss()</span></code></a></dt><dd><p>has label and target arguments</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">weighted_cross_entropy()</span></code></p></li>
<li><p><a class="reference internal" href="#unet.loss.dice_loss" title="unet.loss.dice_loss"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dice_loss()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="unet.loss.weighted_categorical_crossentropy">
<code class="sig-prename descclassname">unet.loss.</code><code class="sig-name descname">weighted_categorical_crossentropy</code><span class="sig-paren">(</span><em class="sig-param">loss_weight</em><span class="sig-paren">)</span><a class="headerlink" href="#unet.loss.weighted_categorical_crossentropy" title="Permalink to this definition">¶</a></dt>
<dd><p>weighted categorical crossentropy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loss_weight</strong> – a list with three weights for all pixels outside the mask, foreground, and pixels close to the
boundary, respectively.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="unet.loss.weighted_cross_entropy_fun">
<code class="sig-prename descclassname">unet.loss.</code><code class="sig-name descname">weighted_cross_entropy_fun</code><span class="sig-paren">(</span><em class="sig-param">loss_weight</em><span class="sig-paren">)</span><a class="headerlink" href="#unet.loss.weighted_cross_entropy_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Weighted cross entropy with foreground pixels having ten times higher weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> – 4D or 5D label tensor</p></li>
<li><p><strong>target</strong> – 4D or 5D target tensor</p></li>
<li><p><strong>loss_weight</strong> – pos_weight for the <code class="xref py py-meth docutils literal notranslate"><span class="pre">tf.nn.weighted_cross_entropy_with_logits()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>weighted cross entropy value</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="unet.loss.weighted_cross_entropy_with_boundary">
<code class="sig-prename descclassname">unet.loss.</code><code class="sig-name descname">weighted_cross_entropy_with_boundary</code><span class="sig-paren">(</span><em class="sig-param">loss_weight</em>, <em class="sig-param">boundary_r=10</em><span class="sig-paren">)</span><a class="headerlink" href="#unet.loss.weighted_cross_entropy_with_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Weighted cross entropy with foreground and boundaries pixels having  higher weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loss_weight</strong> – a list with of weights with length equal to the total number of classes plus one. The last
value is the loss weight fot the boundary and other elements are classes weights</p></li>
<li><p><strong>label</strong> – 4D or 5D label tensor</p></li>
<li><p><strong>target</strong> – 4D or 5D target tensor</p></li>
<li><p><strong>boundary_r</strong> – radius of boundary considered for the higher loss values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>weighted cross entropy value</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#unet.loss.mask_boundary_neighborhood" title="unet.loss.mask_boundary_neighborhood"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mask_boundary_neighborhood()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

</div>
<div class="section" id="module-unet.ops">
<span id="ops"></span><h3>ops<a class="headerlink" href="#module-unet.ops" title="Permalink to this headline">¶</a></h3>
<p>CNN related operations</p>
<dl class="function">
<dt id="unet.ops.MaxPoolingND">
<code class="sig-prename descclassname">unet.ops.</code><code class="sig-name descname">MaxPoolingND</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">s=2</em><span class="sig-paren">)</span><a class="headerlink" href="#unet.ops.MaxPoolingND" title="Permalink to this definition">¶</a></dt>
<dd><p>Maxpooling in x and y direction for 2D and 3D inputs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – input 4D or 5D tensor</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>downscaled of <cite>x</cite> in x and y direction</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#unet.ops.up_conv" title="unet.ops.up_conv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">up_conv()</span></code></a></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">keras.layers.MaxPooling2D()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">keras.layers.MaxPooling3D()</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="unet.ops.accuracy">
<code class="sig-prename descclassname">unet.ops.</code><code class="sig-name descname">accuracy</code><span class="sig-paren">(</span><em class="sig-param">labels</em>, <em class="sig-param">logits</em><span class="sig-paren">)</span><a class="headerlink" href="#unet.ops.accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Measure accuracy metrics. The code calculate the prediction based on the input logits. Metrics are:</p>
<blockquote>
<div><ul class="simple">
<li><p>accuracy: The ratio of correctly labeled voxels to the total number of voxels.</p></li>
<li><p>Jaccard Index: ratio of number of foreground voxels in the intersection of <cite>labels</cite> and <cite>logits</cite> divided by
total number of foreground voxels in the union of <cite>labels</cite> and <cite>logits</cite></p></li>
</ul>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\begin{split}accuracy &amp;= \frac{1}{N \times M \times L} \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} (
    label_{i,j,k} == predict_{i,j,k}) \\
Jaccard &amp;= \frac{
    \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} (label_{i,j,k} \  \&amp;\&amp; \  predict_{i,j,k})
}{
    \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} (label_{i,j,k} \  \| \  predict_{i,j,k})
}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> – 4D or 5D tensor of labels</p></li>
<li><p><strong>logits</strong> – 4D or 5D tensor of prediction logits.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>accuracy and Jaccard Index</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="unet.ops.conv_layer">
<code class="sig-prename descclassname">unet.ops.</code><code class="sig-name descname">conv_layer</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">ChOut</em><span class="sig-paren">)</span><a class="headerlink" href="#unet.ops.conv_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-layer convolution operators consists of three convolutions (2D or 3D based on the input shape) followed by
LeakyReLY.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – input 4D or 5D tensor to the layers</p></li>
<li><p><strong>ChOut</strong> – number of features of outputs of all convolutions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>output of the final layer with same size as <cite>x</cite></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">keras.layers.LeakyReLU()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">keras.layers.Conv2D()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">keras.layers.Conv3D()</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="unet.ops.placeholder_inputs">
<code class="sig-prename descclassname">unet.ops.</code><code class="sig-name descname">placeholder_inputs</code><span class="sig-paren">(</span><em class="sig-param">im_shape</em>, <em class="sig-param">outCh</em><span class="sig-paren">)</span><a class="headerlink" href="#unet.ops.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im_shape</strong> – shape of the input tensor</p></li>
<li><p><strong>outCh</strong> – number of channels in the output</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>image and label placeholders</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="unet.ops.up_conv">
<code class="sig-prename descclassname">unet.ops.</code><code class="sig-name descname">up_conv</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">s=2</em><span class="sig-paren">)</span><a class="headerlink" href="#unet.ops.up_conv" title="Permalink to this definition">¶</a></dt>
<dd><p>upscaling of input tensor in x and y direction using transpose convolution in 2D or 3D.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – input 4D or 5D tensor</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>unscaled of <cite>x</cite> in x and y direction</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#unet.ops.MaxPoolingND" title="unet.ops.MaxPoolingND"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MaxPoolingND()</span></code></a></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">keras.layers..Conv2DTranspose()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">keras.layers..Conv3DTranspose()</span></code></p></li>
</ul>
</div>
</dd></dl>

</div>
<div class="section" id="module-unet.unet">
<span id="unet"></span><h3>unet<a class="headerlink" href="#module-unet.unet" title="Permalink to this headline">¶</a></h3>
<p>Build U-Net model</p>
<dl class="function">
<dt id="unet.unet.unet_model">
<code class="sig-prename descclassname">unet.unet.</code><code class="sig-name descname">unet_model</code><span class="sig-paren">(</span><em class="sig-param">im_shape</em>, <em class="sig-param">nFeature=32</em>, <em class="sig-param">outCh=2</em>, <em class="sig-param">nLayer=3</em>, <em class="sig-param">pool_scale=2</em><span class="sig-paren">)</span><a class="headerlink" href="#unet.unet.unet_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Build U-Net model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – input placeholder</p></li>
<li><p><strong>outCh</strong> – number of output channels</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>keras model</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="utility">
<h2>Utility<a class="headerlink" href="#utility" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-util.confusion_matrix">
<span id="confusion-matrix"></span><h3>confusion matrix<a class="headerlink" href="#module-util.confusion_matrix" title="Permalink to this headline">¶</a></h3>
<p>calculate confusion matrix. Confusion matrix contains</p>
<blockquote>
<div><ul class="simple">
<li><p>TP: True positive</p></li>
<li><p>TN: True negative</p></li>
<li><p>FP: False positive</p></li>
<li><p>FN: False Negative</p></li>
<li><p>TPR: True positive ratio or sensitivity</p></li>
<li><p>TNR: True Negative ratio or specificity</p></li>
<li><p>Dice Index</p></li>
</ul>
</div></blockquote>
<div class="math notranslate nohighlight">
\[Dice = \frac{
        2 \times \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} (label_{i,j,k} \  \&amp;\&amp; \  predict_{i,j,k})
    }{
        \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} label_{i,j,k} \ +              \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} predict_{i,j,k}
    }\]</div>
<p class="rubric">Notes</p>
<p>Arguments are bash arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">param exp_def</dt>
<dd class="field-odd"><p>experiment definition</p>
</dd>
<dt class="field-even">param models_path</dt>
<dd class="field-even"><p>experiment definition</p>
</dd>
<dt class="field-odd">param epoch</dt>
<dd class="field-odd"><p>model saved at this epoch</p>
</dd>
<dt class="field-even">param useMask</dt>
<dd class="field-even"><p>use guide wire and nonIEL masks</p>
</dd>
<dt class="field-odd">returns</dt>
<dd class="field-odd"><p>add a line to the <cite>../model/confusion_matrix.csv</cite> file, which contains confusion matrix of testing and vali</p>
</dd>
</dl>
</div>
<div class="section" id="module-util.load_batch">
<span id="load-batch"></span><h3>load batch<a class="headerlink" href="#module-util.load_batch" title="Permalink to this headline">¶</a></h3>
<p>Load a batch of data.</p>
<p>Creates batches of data randomly in serial or multi-thread parallel fashion.</p>
<dl class="class">
<dt id="util.load_batch.LoadBatchGen">
<em class="property">class </em><code class="sig-prename descclassname">util.load_batch.</code><code class="sig-name descname">LoadBatchGen</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">datasetID</em>, <em class="sig-param">nBatch</em>, <em class="sig-param">label=None</em>, <em class="sig-param">isAug=False</em>, <em class="sig-param">coord_sys='carts'</em>, <em class="sig-param">prob_lim=0.5</em>, <em class="sig-param">isCritique=False</em><span class="sig-paren">)</span><a class="headerlink" href="#util.load_batch.LoadBatchGen" title="Permalink to this definition">¶</a></dt>
<dd><p>data generator class, a sub-class of  Keras’ Sequence class</p>
</dd></dl>

<dl class="class">
<dt id="util.load_batch.LoadBatchGenGPU">
<em class="property">class </em><code class="sig-prename descclassname">util.load_batch.</code><code class="sig-name descname">LoadBatchGenGPU</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">datasetID</em>, <em class="sig-param">nBatch</em>, <em class="sig-param">label</em>, <em class="sig-param">isAug=True</em>, <em class="sig-param">coord_sys='polar'</em>, <em class="sig-param">prob_lim=0.5</em>, <em class="sig-param">isCritique=False</em>, <em class="sig-param">error_list=()</em>, <em class="sig-param">error_case_ratio=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#util.load_batch.LoadBatchGenGPU" title="Permalink to this definition">¶</a></dt>
<dd><p>data generator class, a sub-class of  Keras’ Sequence class</p>
</dd></dl>

<dl class="function">
<dt id="util.load_batch.img_aug">
<code class="sig-prename descclassname">util.load_batch.</code><code class="sig-name descname">img_aug</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">l</em>, <em class="sig-param">coord_sys</em>, <em class="sig-param">prob_lim=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#util.load_batch.img_aug" title="Permalink to this definition">¶</a></dt>
<dd><p>Image augmentation manager.</p>
<p>Based on the coordinate system (<em>Polar</em> vs.  <em>Cartesian</em>),  it selects the corresponding method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – input image 4D or 5D tensor</p></li>
<li><p><strong>l</strong> – input label 4D or 5D tensor</p></li>
<li><p><strong>coord_sys</strong> – coordinate system.  ‘polar’ or ‘carts’ for Polar and Cartesian,  respectively.</p></li>
<li><p><strong>prob_lim</strong> – probability limit for applying each augmentation case.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>augmented im and l</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#util.load_batch.img_aug_carts" title="util.load_batch.img_aug_carts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">img_aug_carts()</span></code></a></p></li>
<li><p><a class="reference internal" href="#util.load_batch.img_aug_polar" title="util.load_batch.img_aug_polar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">img_aug_polar()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="util.load_batch.img_aug_carts">
<code class="sig-prename descclassname">util.load_batch.</code><code class="sig-name descname">img_aug_carts</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">L</em>, <em class="sig-param">prob_lim=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#util.load_batch.img_aug_carts" title="Permalink to this definition">¶</a></dt>
<dd><p>Data augmentation in Cartesian coordinate system.</p>
<p>Applies different image augmentation procedures:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p>mirroring the image along 45 degree (y=x line)</p></li>
<li><p>mirroring the image along the x axis</p></li>
<li><p>mirroring the image along the y axis</p></li>
<li><p>mirroring the image along the z axis for 3D images</p></li>
<li><p>multiple 90 degree rotations</p></li>
<li><p>image intensity scaling by multplying the intensity values with close to one scale value</p></li>
<li><p>image scaling.  See <a class="reference internal" href="#util.load_batch.img_rand_scale" title="util.load_batch.img_rand_scale"><code class="xref py py-meth docutils literal notranslate"><span class="pre">img_rand_scale()</span></code></a></p></li>
</ul>
</div></blockquote>
<p>based on the input probability limit probabilistically applies different augmentation cases.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – input image 4D or 5D tensor</p></li>
<li><p><strong>L</strong> – input label 4D or 5D tensor</p></li>
<li><p><strong>prob_lim</strong> – probability limit for applying each augmentation case.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>augmented image and L</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#util.load_batch.img_aug" title="util.load_batch.img_aug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">img_aug()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="util.load_batch.img_aug_polar">
<code class="sig-prename descclassname">util.load_batch.</code><code class="sig-name descname">img_aug_polar</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">label</em>, <em class="sig-param">prob_lim=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#util.load_batch.img_aug_polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Data augmentation in Polar coordinate.</p>
<p>Applies different image augmentation procedures:</p>
<blockquote>
<div><ul class="simple">
<li><p>random rotations</p></li>
<li><p>image intensity scaling by multplying the intensity valuse with close to one scale value</p></li>
<li><p>image scaling, which randomly crops or add pads and scale the image to the original size</p></li>
</ul>
</div></blockquote>
<p>based on the input probability limit probabilistically applies different augmentation cases.</p>
<dl class="simple">
<dt>Args;</dt><dd><p>image: input image 4D or 5D tensor
label: input label 4D or 5D tensor
prob_lim: probability limit for applying each augmentation case.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>augmented image and l</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#util.load_batch.img_aug" title="util.load_batch.img_aug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">img_aug()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="util.load_batch.img_rand_scale">
<code class="sig-prename descclassname">util.load_batch.</code><code class="sig-name descname">img_rand_scale</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">scale</em>, <em class="sig-param">order</em><span class="sig-paren">)</span><a class="headerlink" href="#util.load_batch.img_rand_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale one image or label batch in Cartesian coordinate system.</p>
<p>scale the image based on the input scale value and interpolation order followed by cropping or padding to
maintain the original image shape.  For interpolation close to the boundaries,  the reflection mode is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – 3D or 4D image or label tensor</p></li>
<li><p><strong>scale</strong> – scalar scale values for x and y direction</p></li>
<li><p><strong>order</strong> – interpolation order</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>same size image with the scale image in the center of it.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="util.load_batch.load_batch">
<code class="sig-prename descclassname">util.load_batch.</code><code class="sig-name descname">load_batch</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">datasetID</em>, <em class="sig-param">nBatch</em>, <em class="sig-param">label=None</em>, <em class="sig-param">isAug=False</em>, <em class="sig-param">coord_sys='carts'</em><span class="sig-paren">)</span><a class="headerlink" href="#util.load_batch.load_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>load a batch of data from im and/or label based on dataset (e.g. test).</p>
<p>This function handel different coordinate system and image augmentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – 4D or 5D image tensor</p></li>
<li><p><strong>datasetID</strong> – index of images in im and/or label along the first axis, which belong to this dataset (e.g.  test)</p></li>
<li><p><strong>nBatch</strong> – batch size</p></li>
<li><p><strong>label</strong> – 4D or 5D label tensor</p></li>
<li><p><strong>isAug</strong> – whether to apply data augmentation. See <a class="reference internal" href="#util.load_batch.img_aug" title="util.load_batch.img_aug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">img_aug()</span></code></a></p></li>
<li><p><strong>coord_sys</strong> – coordinate system {‘polar’ or ‘carts}</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a batch of data as tuple of (image, label)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#util.load_batch.load_batch_parallel" title="util.load_batch.load_batch_parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_batch_parallel()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="util.load_batch.load_batch_parallel">
<code class="sig-prename descclassname">util.load_batch.</code><code class="sig-name descname">load_batch_parallel</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">datasetID</em>, <em class="sig-param">nBatch</em>, <em class="sig-param">label=None</em>, <em class="sig-param">isAug=False</em>, <em class="sig-param">coord_sys='carts'</em>, <em class="sig-param">isCritique=False</em><span class="sig-paren">)</span><a class="headerlink" href="#util.load_batch.load_batch_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>load a batch of data from im and/or label based on dataset (e.g. test) using multi-thread.</p>
<p>This function handel different coordinate system and image augmentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – 4D or 5D image tensor</p></li>
<li><p><strong>datasetID</strong> – index of images in im and/or label along the first axis, which belong to this dataset (e.g.  test)</p></li>
<li><p><strong>nBatch</strong> – batch size</p></li>
<li><p><strong>label</strong> – 4D or 5D label tensor</p></li>
<li><p><strong>isAug</strong> – whether to apply data augmentation. See <a class="reference internal" href="#util.load_batch.img_aug" title="util.load_batch.img_aug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">img_aug()</span></code></a></p></li>
<li><p><strong>coord_sys</strong> – coordinate system {‘polar’ or ‘carts}</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a batch of data as tuple of (image, label)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#util.load_batch.load_batch" title="util.load_batch.load_batch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_batch()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="util.load_batch.polar_zoom">
<code class="sig-prename descclassname">util.load_batch.</code><code class="sig-name descname">polar_zoom</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">scale</em>, <em class="sig-param">order=1</em><span class="sig-paren">)</span><a class="headerlink" href="#util.load_batch.polar_zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>apply image scaling to polar images along the radius axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – input image</p></li>
<li><p><strong>scale</strong> – scaling factor</p></li>
<li><p><strong>order</strong> – interpolation order.  0 for nearest and 1 for linear.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>scaled image.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-util.load_data">
<span id="load-data"></span><h3>load data<a class="headerlink" href="#module-util.load_data" title="Permalink to this headline">¶</a></h3>
<p>Convert an 2D or 3D image from polar or cylindrical coordinate to the
cartesian coordinate.</p>
<dl class="function">
<dt id="util.load_data.im_fix_width">
<code class="sig-prename descclassname">util.load_data.</code><code class="sig-name descname">im_fix_width</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">w</em><span class="sig-paren">)</span><a class="headerlink" href="#util.load_data.im_fix_width" title="Permalink to this definition">¶</a></dt>
<dd><p>pad or crop the 3D image to have width and length equal to the input width in Cartesian coordinate system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – input image</p></li>
<li><p><strong>w</strong> – output width size</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>image with the <cite>w</cite> width and length</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="util.load_data.load_train_data">
<code class="sig-prename descclassname">util.load_data.</code><code class="sig-name descname">load_train_data</code><span class="sig-paren">(</span><em class="sig-param">folder_path</em>, <em class="sig-param">im_shape</em>, <em class="sig-param">coord_sys</em>, <em class="sig-param">saveOutput=False</em><span class="sig-paren">)</span><a class="headerlink" href="#util.load_data.load_train_data" title="Permalink to this definition">¶</a></dt>
<dd><p>loading the training data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>folder_path</strong> – the input folder path containing the data</p></li>
<li><p><strong>im_shape</strong> – shape of the images in the dataset in (depth,width,length,channel) format</p></li>
<li><p><strong>coord_sys</strong> – coordinate system (<cite>polar</cite> or <cite>carts</cite>)</p></li>
<li><p><strong>saveOutput</strong> – save the output of the function to a h5 file</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>im</strong>: image tensor of dataset with first row is sample ID</p></li>
<li><p><strong>label</strong>: label tensor similar to <cite>im</cite></p></li>
<li><p><strong>train_data_id</strong>: row IDs of training samples</p></li>
<li><p><strong>test_data_id</strong>: row IDs of testing samples</p></li>
<li><p><strong>valid_data_id</strong>: row IDs of validation samples</p></li>
<li><p><strong>sample_caseID</strong>: caseID of each row</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#util.load_data.make_dataset" title="util.load_data.make_dataset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_dataset()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="util.load_data.make_dataset">
<code class="sig-prename descclassname">util.load_data.</code><code class="sig-name descname">make_dataset</code><span class="sig-paren">(</span><em class="sig-param">folder_path</em>, <em class="sig-param">im_shape</em>, <em class="sig-param">coord_sys</em>, <em class="sig-param">carts_w=512</em><span class="sig-paren">)</span><a class="headerlink" href="#util.load_data.make_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce dataset based oon the results of <a class="reference internal" href="#module-util.process_oct_folder" title="util.process_oct_folder"><code class="xref py py-meth docutils literal notranslate"><span class="pre">util.process_oct_folder()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>folder_path</strong> – the path to the folder that contains the images</p></li>
<li><p><strong>im_shape</strong> – shape of the images in the dataset in (depth,width,length,channel) format</p></li>
<li><p><strong>coord_sys</strong> – coordinate system (<cite>polar</cite> or <cite>carts</cite>)</p></li>
<li><p><strong>carts_w</strong> – width of the image in case <cite>coord_sys == carts</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>image and label as the 4D or 5D tensors.  sample_caseID contains the case ID for each row of image and label</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#module-util.process_oct_folder" title="util.process_oct_folder"><code class="xref py py-meth docutils literal notranslate"><span class="pre">util.process_oct_folder()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

</div>
<div class="section" id="module-util.plot_log_file">
<span id="plot-log-file"></span><h3>plot log file<a class="headerlink" href="#module-util.plot_log_file" title="Permalink to this headline">¶</a></h3>
<p>plot the log file within the save model folder. 111</p>
<p>plots the train and validation loss values over last 100 recorded performance evaluations and update the
plot every 5 second.  The figure has two subplots: top one has all the results and bottom one has last 100 log
records.</p>
<p class="rubric">Notes</p>
<p>Arguments are bash arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">param exp_def</dt>
<dd class="field-odd"><p>the experiment definition used for saving the model.</p>
</dd>
<dt class="field-even">param models_path</dt>
<dd class="field-even"><p>the path that model folder for <cite>exp_def</cite></p>
</dd>
<dt class="field-odd">returns</dt>
<dd class="field-odd"><p>PyPlot figure with two subplots.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">train()</span></code></p></li>
</ul>
</div>
</div>
<div class="section" id="module-util.polar2cartesian">
<span id="polar-to-cartesian"></span><h3>polar to cartesian<a class="headerlink" href="#module-util.polar2cartesian" title="Permalink to this headline">¶</a></h3>
<p>Convert an 2D or 3D image from polar or cylindrical coordinate to the
cartesian coordinate.</p>
<dl class="function">
<dt id="util.polar2cartesian.polar2cartesian">
<code class="sig-prename descclassname">util.polar2cartesian.</code><code class="sig-name descname">polar2cartesian</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">r0=0</em>, <em class="sig-param">full=True</em>, <em class="sig-param">deg=1</em>, <em class="sig-param">scale=1</em><span class="sig-paren">)</span><a class="headerlink" href="#util.polar2cartesian.polar2cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input image from polar to <em>Cartesian</em> coordinate system.</p>
<p>A rectangle image in the Polar coordinate system is a circle in the Cartesian coordinate system.  The output
rectangle frame can inscribe the circle or be inscribed by the circle.  The Radius dimension is along the rows and
the zero radius can be the first row or can be a any other row, which crop the rows above that zero-radius row.
The final image can be scale by a factor and the interpolation can be done in zero or one order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – input polar 2D or 3D image. Single multi-channel. The 3D is in cylindrical coordinate system.</p></li>
<li><p><strong>r0</strong> – the row index of zero radius. The rows with lower index will be removed.  Default is 0.</p></li>
<li><p><strong>full</strong> – True if the output boundary inscribes the resulted circular boundary or be inscribed by the circular
boundary.  Default is True.</p></li>
<li><p><strong>deg</strong> – degree of interpolation.  0 for nearest neighbor and 1 for linear interpolation.  Default is 1.</p></li>
<li><p><strong>scale</strong> – the scaling ratio of the final result.  Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The converted version of im in Cartesian coordinate system.  The final size depends on all the arguments.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="util.polar2cartesian.polar2cartesian_large_3d_file">
<code class="sig-prename descclassname">util.polar2cartesian.</code><code class="sig-name descname">polar2cartesian_large_3d_file</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">r0=0</em>, <em class="sig-param">full=True</em>, <em class="sig-param">deg=1</em>, <em class="sig-param">scale=1</em>, <em class="sig-param">chunk_size=100</em><span class="sig-paren">)</span><a class="headerlink" href="#util.polar2cartesian.polar2cartesian_large_3d_file" title="Permalink to this definition">¶</a></dt>
<dd><p>polar to Cartesian conversion for big files.</p>
<p>Similar to <a class="reference internal" href="#util.polar2cartesian.polar2cartesian" title="util.polar2cartesian.polar2cartesian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">polar2cartesian()</span></code></a> but convert chunk by chunk to handle very large images.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – input polar 2D or 3D image. The 3D is in cylindrical coordinate system.</p></li>
<li><p><strong>r0</strong> – the row index of zero radius. The rows with lower index will be removed.  Default is 0.</p></li>
<li><p><strong>full</strong> – True if the output boundary inscribes the resulted circular boundary or be inscribed by the circular
boundary.  Default is True.</p></li>
<li><p><strong>deg</strong> – degree of interpolation.  0 for nearest neighbor and 1 for linear interpolation.  Default is 1.</p></li>
<li><p><strong>scale</strong> – the scaling ratio of the final result.  Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The converted version of im in Cartesian coordinate system.  The final size depends on all the arguments.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-util.process_oct_folder">
<span id="process-oct-folder"></span><h3>process oct folder<a class="headerlink" href="#module-util.process_oct_folder" title="Permalink to this headline">¶</a></h3>
<p>process OCT folder to generate the segmentation labels of cases. Each case has all these three files</p>
<ul class="simple">
<li><p><a href="#id1"><span class="problematic" id="id2">**</span></a>.PSTIF</p></li>
<li><p><a href="#id3"><span class="problematic" id="id4">**</span></a>.INI</p></li>
<li><p><a href="#id5"><span class="problematic" id="id6">**</span></a>ROI.txt</p></li>
</ul>
<dl class="function">
<dt id="util.process_oct_folder.process_oct_folder">
<code class="sig-prename descclassname">util.process_oct_folder.</code><code class="sig-name descname">process_oct_folder</code><span class="sig-paren">(</span><em class="sig-param">folder_path</em>, <em class="sig-param">scale=0.25</em><span class="sig-paren">)</span><a class="headerlink" href="#util.process_oct_folder.process_oct_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>process OCT folder to generate the segmentation labels of cases.</p>
<p>The <em>Cartesian</em> output file can be scale.  Each case should have all these three files</p>
<blockquote>
<div><ul class="simple">
<li><p>.PSTIF</p></li>
<li><p>.INI</p></li>
<li><p>ROI.txt</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>folder_path</strong> – the folder containing the file</p></li>
<li><p><strong>scale</strong> – the scale of the Cartisian output file</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>the case id and slice id for each sample
: It saves three files in the <cite>folder_path</cite> for each case with a suffix:</p>
<ul class="simple">
<li><p><strong>-im.tif</strong>: the image in cartesian, possibly scaled.</p></li>
<li><p><strong>-SegP.tif</strong>: The segmentation results in polar coordinate system.</p></li>
<li><p><strong>-SegP.tif</strong>: The segmentation results in <em>Cartesian</em> coordinate system.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>case_slice_id</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#util.polar2cartesian.polar2cartesian_large_3d_file" title="util.polar2cartesian.polar2cartesian_large_3d_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">util.polar2cartesian.polar2cartesian_large_3d_file()</span></code></a></p></li>
<li><p><a class="reference internal" href="#util.read_oct_roi_file.read_oct_roi_file" title="util.read_oct_roi_file.read_oct_roi_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">util.read_oct_roi_file.read_oct_roi_file()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

</div>
<div class="section" id="module-util.read_oct_roi_file">
<span id="read-oct-roi-file"></span><h3>read oct roi file<a class="headerlink" href="#module-util.read_oct_roi_file" title="Permalink to this headline">¶</a></h3>
<p>Read ROI file generated based on the and generate segmentation results.</p>
<dl class="function">
<dt id="util.read_oct_roi_file.boundary_mask">
<code class="sig-prename descclassname">util.read_oct_roi_file.</code><code class="sig-name descname">boundary_mask</code><span class="sig-paren">(</span><em class="sig-param">obj_list</em>, <em class="sig-param">im_shape</em><span class="sig-paren">)</span><a class="headerlink" href="#util.read_oct_roi_file.boundary_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>generate lumen or IEL mask based on the point list.</p>
<p>Based on the periodic nature of polar coordinate system, the boundary within [0, 2 pi] is copied to [- 2 pi, 0] and
[2 pi, 4 pi]. The interpolation happened along the path for x and y independently. Number of points interpolated
between each two consecutive points is based on the largest arc length between all pairs of consecutive points
measured in the cartesian coordinate system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj_list</strong> – list of a single boundary in a single plane</p></li>
<li><p><strong>im_shape</strong> – the original image shape</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A mask image based on the <cite>obj_list</cite> and size of <cite>im_obj_list</cite>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#util.read_oct_roi_file.read_oct_roi_file" title="util.read_oct_roi_file.read_oct_roi_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_oct_roi_file()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="util.read_oct_roi_file.read_oct_roi_file">
<code class="sig-prename descclassname">util.read_oct_roi_file.</code><code class="sig-name descname">read_oct_roi_file</code><span class="sig-paren">(</span><em class="sig-param">file_path</em>, <em class="sig-param">im_shape</em><span class="sig-paren">)</span><a class="headerlink" href="#util.read_oct_roi_file.read_oct_roi_file" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a label tensor based on a <cite>*ROI.txt</cite> file.  The label tensor is a 8-bit integer, which each bit
encode one the classes:</p>
<blockquote>
<div><ul class="simple">
<li><p>bit 1 (2**0) encode <cite>gw</cite> (Guide Wire, where guide wire has shadow)</p></li>
<li><p>bit 2 (2**1) encode <cite>noniel</cite> (NonIEL, where IEL is not visible)</p></li>
<li><p>bit 2  (2**2) encode <cite>lumen</cite> area</p></li>
<li><dl class="simple">
<dt>bit 3  (2**3) encode <cite>iel</cite> area (the <em>Tunica Intima</em> layer), which is the layer between <cite>lumen</cite> and <cite>iel</cite></dt><dd><p>boundaries.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>bit 4 (2**4) encode <cite>eel</cite> area (the <em>Tunica Media</em> layer), which is the layer between <cite>iel</cite> and <cite>eel</cite></dt><dd><p>boundaries</p>
</dd>
</dl>
</li>
<li><p>other bits are not utilized and can be used for other classes in future.</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> – file path to <cite>*ROI.txt</cite> file for a case</p></li>
<li><p><strong>im_shape</strong> – the output image shape.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the output label image</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>uint8</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#util.read_oct_roi_file.boundary_mask" title="util.read_oct_roi_file.boundary_mask"><code class="xref py py-meth docutils literal notranslate"><span class="pre">boundary_mask()</span></code></a></p></li>
<li><p><a class="reference internal" href="#util.read_oct_roi_file.roi_file_parser" title="util.read_oct_roi_file.roi_file_parser"><code class="xref py py-meth docutils literal notranslate"><span class="pre">roi_file_parser()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="util.read_oct_roi_file.roi_file_parser">
<code class="sig-prename descclassname">util.read_oct_roi_file.</code><code class="sig-name descname">roi_file_parser</code><span class="sig-paren">(</span><em class="sig-param">file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#util.read_oct_roi_file.roi_file_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse roi file and output the lists of objects.</p>
<p>The object list is a dictionary that has a list for each keys.  Each class of object has a key.  Keys are:</p>
<ul class="simple">
<li><p><strong>lumen</strong>: vessel lumen boundary</p></li>
<li><p><strong>iel</strong>: IEL boundary</p></li>
<li><p><strong>gw</strong>: guide wire arc defined by three points.</p></li>
<li><p><strong>noniel</strong>: None IEL arc, which is the places that IEL is not visible, defined by three points</p></li>
</ul>
<p>Each key’s value is a nested list, which first index represents a complete boundary or an arc whitin a plane.
The second index represents a point within the boundary or arc.  The third index represnets the x, y, z
coordinates of the point.</p>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>In <cite>*ROI.txt</cite> files:</dt><dd><ul class="simple">
<li><p>Each file has a header line as <em>ROIformat</em>.</p></li>
<li><p>The first record of a boundary or an arc section has a final field that contain the classification label.</p></li>
<li><p>Each boundary record section finishes with the keyword <em>closed</em>.</p></li>
<li><p>Boundary records start with keyword <em>Snake</em>.</p></li>
<li><p>Arc records start with keyword <em>Angle</em>.</p></li>
<li><dl class="simple">
<dt>Lumen class can have one of the following classification labels:</dt><dd><ol class="arabic simple">
<li><p><em>lumen</em></p></li>
<li><p><em>fibro-fatty</em></p></li>
<li><p><em>fibrous</em></p></li>
<li><p><em>fc</em></p></li>
<li><p><em>fibrous</em></p></li>
<li><p><em>fa</em></p></li>
<li><p><em>normal</em></p></li>
</ol>
</dd>
</dl>
</li>
<li><p>There are some classifications that are ignore in this function such as <em>calcification</em></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file_path</strong> – the path to <cite>*ROI.txt</cite> file</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The object_list dictionary.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#util.read_oct_roi_file.read_oct_roi_file" title="util.read_oct_roi_file.read_oct_roi_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_oct_roi_file()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">OCTseg</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Mohammad Haft-Javaherian.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>