%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{OCTseg}
\date{Aug 27, 2019}
\release{}
\author{Mohammad Haft-Javaherian}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\chapter{Training and Testing}
\label{\detokenize{index:training-and-testing}}\index{main() (in module train)@\spxentry{main()}\spxextra{in module train}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:train.main}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{train.}}\sphinxbfcode{\sphinxupquote{main}}}{}{}
Train or test a U-Net model to analyze OCT images.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{***Note**}} \textendash{} \sphinxstylestrong{All arguments are bash arguments}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{exp\_def}} \textendash{} experiment definition

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{models\_path}} \textendash{} path for saving models

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lr}} \textendash{} learning rate

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lr\_decay}} \textendash{} learning rate step for decay

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_pat}} \textendash{} data folder path

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nEpoch}} \textendash{} number of epochs

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nBatch}} \textendash{} batch size

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outCh}} \textendash{} size of output channel

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inCh}} \textendash{} size of input channel

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nZ}} \textendash{} size of input depth

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{w}} \textendash{} size of input width (number of columns)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{l}} \textendash{} size of input Length (number of rows)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{loss\_w}} \textendash{} loss wights

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{isAug}} \textendash{} Is data augmentation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{isCarts}} \textendash{} whether images should be converted into Cartesian

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{isTest}} \textendash{} Is test run instead of train

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{testEpoch}} \textendash{} epoch of the saved model for testing

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{saveEpoch}} \textendash{} epoch interval to save the model

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{logEpoch}} \textendash{} epoch interval to save the log”)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nFeature}} \textendash{} number of features in the first layer

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nLayer}} \textendash{} number of layers in the U-Nnet model

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gpu\_id}} \textendash{} ID of GPUs to be used

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{optimizer}} \textendash{} keras optimizer. see \sphinxcode{\sphinxupquote{keras.optimizers()}}

\end{itemize}

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:unet.unet.unet_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{unet.unet.unet\_model()}}}}}

\item {} 
{\hyperref[\detokenize{index:unet.loss.multi_loss_fun}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{unet.loss.multi\_loss\_fun()}}}}}

\item {} 
{\hyperref[\detokenize{index:util.load_data.load_train_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{util.load\_data.load\_train\_data()}}}}}

\item {} 
{\hyperref[\detokenize{index:util.load_batch.load_batch_parallel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{util.load\_batch.load\_batch\_parallel()}}}}}

\item {} 
\sphinxcode{\sphinxupquote{keras.utils.multi\_gpu\_model()}}

\item {} 
\sphinxcode{\sphinxupquote{keras.optimizers()}}

\end{itemize}



\end{fulllineitems}



\chapter{U-Net}
\label{\detokenize{index:u-net}}

\section{loss}
\label{\detokenize{index:module-unet.loss}}\label{\detokenize{index:loss}}\index{unet.loss (module)@\spxentry{unet.loss}\spxextra{module}}
CNN related loss functions
\index{dice\_loss() (in module unet.loss)@\spxentry{dice\_loss()}\spxextra{in module unet.loss}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.loss.dice_loss}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.loss.}}\sphinxbfcode{\sphinxupquote{dice\_loss}}}{\emph{label}, \emph{target}}{}
Soft Dice coefficient loss

TP, FP, and FN are true positive, false positive, and false negative.
\begin{equation*}
\begin{split}dice  &=  \frac{2 \times TP}{ 2 \times TP + FN + FP} \\
dice  &=  \frac{2 \times TP}{(TP + FN) + (TP + FP)}\end{split}
\end{equation*}
objective is to maximize the dice, thus the loss is negate of dice for numerical stability (+1 in denominator)
and fixing the loss range (+1 in numerator and +1 to the negated dice).

The final Dice loss is formulated as
\begin{equation*}
\begin{split}dice \ loss = 1 - \frac{2 \times TP + 1}{(TP + FN) + (TP + FP ) + 1}\end{split}
\end{equation*}
it is soft as each components of the confusion matrix (TP, FP, and FN) are estimated by dot product of
probability instead of hard classification
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} \textendash{} 4D or 5D label tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} \textendash{} 4D or 5D target tensor

\end{itemize}

\item[{Returns}] \leavevmode
dice loss

\end{description}\end{quote}

\end{fulllineitems}

\index{multi\_loss\_fun() (in module unet.loss)@\spxentry{multi\_loss\_fun()}\spxextra{in module unet.loss}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.loss.multi_loss_fun}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.loss.}}\sphinxbfcode{\sphinxupquote{multi\_loss\_fun}}}{\emph{loss\_weight}}{}
Semantic loss function based on the weighted cross entropy and dice and wighted by the loss weights in the input
argument
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{loss\_weight}} \textendash{} a list with two weights for weighted cross entropy and dice losses, respectively.

\item[{Returns}] \leavevmode
\begin{description}
\item[{function, which similar to {\hyperref[\detokenize{index:unet.loss.weighted_cross_entropy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{weighted\_cross\_entropy()}}}}} and {\hyperref[\detokenize{index:unet.loss.dice_loss}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dice\_loss()}}}}}}] \leavevmode
has label and target arguments

\end{description}


\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:unet.loss.weighted_cross_entropy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{weighted\_cross\_entropy()}}}}}

\item {} 
{\hyperref[\detokenize{index:unet.loss.dice_loss}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dice\_loss()}}}}}

\end{itemize}



\end{fulllineitems}

\index{weighted\_cross\_entropy() (in module unet.loss)@\spxentry{weighted\_cross\_entropy()}\spxextra{in module unet.loss}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.loss.weighted_cross_entropy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.loss.}}\sphinxbfcode{\sphinxupquote{weighted\_cross\_entropy}}}{\emph{label}, \emph{target}}{}
Weighted cross entropy with foreground pixels having ten times higher weights
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} \textendash{} 4D or 5D label tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} \textendash{} 4D or 5D target tensor

\end{itemize}

\item[{Returns}] \leavevmode
weighted cross entropy value

\end{description}\end{quote}

\end{fulllineitems}

\index{weighted\_cross\_entropy\_with\_boundary() (in module unet.loss)@\spxentry{weighted\_cross\_entropy\_with\_boundary()}\spxextra{in module unet.loss}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.loss.weighted_cross_entropy_with_boundary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.loss.}}\sphinxbfcode{\sphinxupquote{weighted\_cross\_entropy\_with\_boundary}}}{\emph{label}, \emph{target}}{}
Weighted cross entropy with foreground pixels having ten times higher weights
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} \textendash{} 4D or 5D label tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} \textendash{} 4D or 5D target tensor

\end{itemize}

\item[{Returns}] \leavevmode
weighted cross entropy value

\end{description}\end{quote}

\end{fulllineitems}



\section{ops}
\label{\detokenize{index:module-unet.ops}}\label{\detokenize{index:ops}}\index{unet.ops (module)@\spxentry{unet.ops}\spxextra{module}}
CNN related operations
\index{MaxPoolingND() (in module unet.ops)@\spxentry{MaxPoolingND()}\spxextra{in module unet.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.ops.MaxPoolingND}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.ops.}}\sphinxbfcode{\sphinxupquote{MaxPoolingND}}}{\emph{x}}{}
Maxpooling in x and y direction for 2D and 3D inputs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} input 4D or 5D tensor

\item[{Returns}] \leavevmode
downscaled of \sphinxtitleref{x} in x and y direction

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:unet.ops.up_conv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{up\_conv()}}}}}

\item {} 
\sphinxcode{\sphinxupquote{keras.layers.MaxPooling2D()}}

\item {} 
\sphinxcode{\sphinxupquote{keras.layers.MaxPooling3D()}}

\end{itemize}



\end{fulllineitems}

\index{accuracy() (in module unet.ops)@\spxentry{accuracy()}\spxextra{in module unet.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.ops.accuracy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.ops.}}\sphinxbfcode{\sphinxupquote{accuracy}}}{\emph{labels}, \emph{logits}}{}
Measure accuracy metrics. The code calculate the prediction based on the input logits. Metrics are:
\begin{itemize}
\item {} 
accuracy: The ratio of correctly labeled voxels to the total number of voxels.

\item {} 
Jaccard Index: ratio of number of foreground voxels in the intersection of \sphinxtitleref{labels} and \sphinxtitleref{logits} divided by
total number of foreground voxels in the union of \sphinxtitleref{labels} and \sphinxtitleref{logits}

\end{itemize}
\begin{equation*}
\begin{split}accuracy &= \frac{1}{N \times M \times L} \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} (
    label_{i,j,k} == predict_{i,j,k}) \\
Jaccard &= \frac{
    \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} (label_{i,j,k} \  \&\& \  predict_{i,j,k})
}{
    \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} (label_{i,j,k} \  \| \  predict_{i,j,k})
}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{labels}} \textendash{} 4D or 5D tensor of labels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{logits}} \textendash{} 4D or 5D tensor of prediction logits.

\end{itemize}

\item[{Returns}] \leavevmode
accuracy and Jaccard Index

\end{description}\end{quote}

\end{fulllineitems}

\index{conv\_layer() (in module unet.ops)@\spxentry{conv\_layer()}\spxextra{in module unet.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.ops.conv_layer}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.ops.}}\sphinxbfcode{\sphinxupquote{conv\_layer}}}{\emph{x}, \emph{ChOut}}{}
Multi-layer convolution operators consists of three convolutions (2D or 3D based on the input shape) followed by
LeakyReLY.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} input 4D or 5D tensor to the layers

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ChOut}} \textendash{} number of features of outputs of all convolutions

\end{itemize}

\item[{Returns}] \leavevmode
output of the final layer with same size as \sphinxtitleref{x}

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{keras.layers.LeakyReLU()}}

\item {} 
\sphinxcode{\sphinxupquote{keras.layers.Conv2D()}}

\item {} 
\sphinxcode{\sphinxupquote{keras.layers.Conv3D()}}

\end{itemize}



\end{fulllineitems}

\index{placeholder\_inputs() (in module unet.ops)@\spxentry{placeholder\_inputs()}\spxextra{in module unet.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.ops.placeholder_inputs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.ops.}}\sphinxbfcode{\sphinxupquote{placeholder\_inputs}}}{\emph{im\_shape}, \emph{outCh}}{}
Generate placeholder variables to represent the input tensors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im\_shape}} \textendash{} shape of the input tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outCh}} \textendash{} number of channels in the output

\end{itemize}

\item[{Returns}] \leavevmode
image and label placeholders

\end{description}\end{quote}

\end{fulllineitems}

\index{up\_conv() (in module unet.ops)@\spxentry{up\_conv()}\spxextra{in module unet.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.ops.up_conv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.ops.}}\sphinxbfcode{\sphinxupquote{up\_conv}}}{\emph{x}}{}
upscaling of input tensor in x and y direction using transpose convolution in 2D or 3D.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} input 4D or 5D tensor

\item[{Returns}] \leavevmode
unscaled of \sphinxtitleref{x} in x and y direction

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:unet.ops.MaxPoolingND}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MaxPoolingND()}}}}}

\item {} 
\sphinxcode{\sphinxupquote{keras.layers..Conv2DTranspose()}}

\item {} 
\sphinxcode{\sphinxupquote{keras.layers..Conv3DTranspose()}}

\end{itemize}



\end{fulllineitems}



\section{unet}
\label{\detokenize{index:module-unet.unet}}\label{\detokenize{index:unet}}\index{unet.unet (module)@\spxentry{unet.unet}\spxextra{module}}
Build U-Net model
\index{unet\_model() (in module unet.unet)@\spxentry{unet\_model()}\spxextra{in module unet.unet}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.unet.unet_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.unet.}}\sphinxbfcode{\sphinxupquote{unet\_model}}}{\emph{im\_shape}, \emph{nFeature=32}, \emph{outCh=2}, \emph{nLayer=3}}{}
Build U-Net model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} input placeholder

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outCh}} \textendash{} number of output channels

\end{itemize}

\item[{Returns}] \leavevmode
keras model

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Utility}
\label{\detokenize{index:utility}}

\section{confusion matrix}
\label{\detokenize{index:module-util.confusion_matrix}}\label{\detokenize{index:confusion-matrix}}\index{util.confusion\_matrix (module)@\spxentry{util.confusion\_matrix}\spxextra{module}}
calculate confusion matrix. Confusion matrix contains
\begin{itemize}
\item {} 
TP: True positive

\item {} 
TN: True negative

\item {} 
FP: False positive

\item {} 
FN: False Negative

\item {} 
TPR: True positive ratio or sensitivity

\item {} 
TNR: True Negative ratio or specificity

\item {} 
Dice Index

\end{itemize}
\begin{equation*}
\begin{split}Dice = \frac{
        2 \times \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} (label_{i,j,k} \  \&\& \  predict_{i,j,k})
    }{
        \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} label_{i,j,k} \ +              \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} predict_{i,j,k}
    }\end{split}
\end{equation*}\subsubsection*{Notes}

Arguments are bash arguments.
\begin{quote}\begin{description}
\item[{param exp\_def}] \leavevmode
experiment definition

\item[{param models\_path}] \leavevmode
experiment definition

\item[{param epoch}] \leavevmode
model saved at this epoch

\item[{param useMask}] \leavevmode
use guide wire and nonIEL masks

\item[{returns}] \leavevmode
add a line to the \sphinxtitleref{../model/confusion\_matrix.csv} file, which contains confusion matrix of testing and vali

\end{description}\end{quote}


\section{load batch}
\label{\detokenize{index:module-util.load_batch}}\label{\detokenize{index:load-batch}}\index{util.load\_batch (module)@\spxentry{util.load\_batch}\spxextra{module}}
Load a batch of data.

Creates batches of data randomly in serial or multi-thread parallel fashion.
\index{LoadBatchGen (class in util.load\_batch)@\spxentry{LoadBatchGen}\spxextra{class in util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.LoadBatchGen}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{LoadBatchGen}}}{\emph{im}, \emph{datasetID}, \emph{nBatch}, \emph{label=None}, \emph{isAug=False}, \emph{coord\_sys='carts'}}{}
data generator class, a sub-class of  Keras’ Sequence class

\end{fulllineitems}

\index{img\_aug() (in module util.load\_batch)@\spxentry{img\_aug()}\spxextra{in module util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.img_aug}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{img\_aug}}}{\emph{im}, \emph{l}, \emph{coord\_sys}, \emph{prob\_lim=0.5}}{}
Image augmentation manager.

Based on the coordinate system (\sphinxstyleemphasis{Polar} vs.  \sphinxstyleemphasis{Cartesian}),  it selects the corresponding method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} input image 4D or 5D tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{l}} \textendash{} input label 4D or 5D tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_sys}} \textendash{} coordinate system.  ‘polar’ or ‘carts’ for Polar and Cartesian,  respectively.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prob\_lim}} \textendash{} probability limit for applying each augmentation case.

\end{itemize}

\item[{Returns}] \leavevmode
augmented im and l

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.load_batch.img_aug_carts}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_aug\_carts()}}}}}

\item {} 
{\hyperref[\detokenize{index:util.load_batch.img_aug_polar}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_aug\_polar()}}}}}

\end{itemize}



\end{fulllineitems}

\index{img\_aug\_carts() (in module util.load\_batch)@\spxentry{img\_aug\_carts()}\spxextra{in module util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.img_aug_carts}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{img\_aug\_carts}}}{\emph{image}, \emph{L}, \emph{prob\_lim=0.5}}{}
Data augmentation in Cartesian coordinate system.

Applies different image augmentation procedures:
\begin{quote}
\begin{itemize}
\item {} 
mirroring the image along 45 degree (y=x line)

\item {} 
mirroring the image along the x axis

\item {} 
mirroring the image along the y axis

\item {} 
mirroring the image along the z axis for 3D images

\item {} 
multiple 90 degree rotations

\item {} 
image intensity scaling by multplying the intensity values with close to one scale value

\item {} 
image scaling.  See {\hyperref[\detokenize{index:util.load_batch.img_rand_scale}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_rand\_scale()}}}}}

\end{itemize}

based on the input probability limit probabilistically applies different augmentation cases.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{image}} \textendash{} input image 4D or 5D tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{L}} \textendash{} input label 4D or 5D tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prob\_lim}} \textendash{} probability limit for applying each augmentation case.

\end{itemize}

\item[{Returns}] \leavevmode
augmented image and L

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.load_batch.img_aug}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_aug()}}}}}

\end{itemize}



\end{fulllineitems}

\index{img\_aug\_polar() (in module util.load\_batch)@\spxentry{img\_aug\_polar()}\spxextra{in module util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.img_aug_polar}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{img\_aug\_polar}}}{\emph{image}, \emph{label}, \emph{prob\_lim=0.5}}{}
Data augmentation in Polar coordinate.

Applies different image augmentation procedures:
\begin{itemize}
\item {} 
random rotations

\item {} 
image intensity scaling by multplying the intensity valuse with close to one scale value

\item {} 
image scaling, which randomly crops or add pads and scale the image to the original size

\end{itemize}

based on the input probability limit probabilistically applies different augmentation cases.
\begin{description}
\item[{Args;}] \leavevmode
image: input image 4D or 5D tensor
label: input label 4D or 5D tensor
prob\_lim: probability limit for applying each augmentation case.

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
augmented image and l

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.load_batch.img_aug}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_aug()}}}}}

\end{itemize}



\end{fulllineitems}

\index{img\_rand\_scale() (in module util.load\_batch)@\spxentry{img\_rand\_scale()}\spxextra{in module util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.img_rand_scale}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{img\_rand\_scale}}}{\emph{im}, \emph{scale}, \emph{order}}{}
Scale one image or label batch in Cartesian coordinate system.

scale the image based on the input scale value and interpolation order followed by cropping or padding to
maintain the original image shape.  For interpolation close to the boundaries,  the reflection mode is used.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} 3D or 4D image or label tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale}} \textendash{} scalar scale values for x and y direction

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order}} \textendash{} interpolation order

\end{itemize}

\item[{Returns}] \leavevmode
same size image with the scale image in the center of it.

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_batch() (in module util.load\_batch)@\spxentry{load\_batch()}\spxextra{in module util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.load_batch}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{load\_batch}}}{\emph{im}, \emph{datasetID}, \emph{nBatch}, \emph{label=None}, \emph{isAug=False}, \emph{coord\_sys='carts'}}{}
load a batch of data from im and/or label based on dataset (e.g. test).

This function handel different coordinate system and image augmentation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} 4D or 5D image tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{datasetID}} \textendash{} index of images in im and/or label along the first axis, which belong to this dataset (e.g.  test)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nBatch}} \textendash{} batch size

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} \textendash{} 4D or 5D label tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{isAug}} \textendash{} whether to apply data augmentation. See {\hyperref[\detokenize{index:util.load_batch.img_aug}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_aug()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_sys}} \textendash{} coordinate system \{‘polar’ or ‘carts\}

\end{itemize}

\item[{Returns}] \leavevmode
a batch of data as tuple of (image, label)

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.load_batch.load_batch_parallel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{load\_batch\_parallel()}}}}}

\end{itemize}



\end{fulllineitems}

\index{load\_batch\_parallel() (in module util.load\_batch)@\spxentry{load\_batch\_parallel()}\spxextra{in module util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.load_batch_parallel}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{load\_batch\_parallel}}}{\emph{im}, \emph{datasetID}, \emph{nBatch}, \emph{label=None}, \emph{isAug=False}, \emph{coord\_sys='carts'}}{}
load a batch of data from im and/or label based on dataset (e.g. test) using multi-thread.

This function handel different coordinate system and image augmentation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} 4D or 5D image tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{datasetID}} \textendash{} index of images in im and/or label along the first axis, which belong to this dataset (e.g.  test)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nBatch}} \textendash{} batch size

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} \textendash{} 4D or 5D label tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{isAug}} \textendash{} whether to apply data augmentation. See {\hyperref[\detokenize{index:util.load_batch.img_aug}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_aug()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_sys}} \textendash{} coordinate system \{‘polar’ or ‘carts\}

\end{itemize}

\item[{Returns}] \leavevmode
a batch of data as tuple of (image, label)

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.load_batch.load_batch}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{load\_batch()}}}}}

\end{itemize}



\end{fulllineitems}



\section{load data}
\label{\detokenize{index:module-util.load_data}}\label{\detokenize{index:load-data}}\index{util.load\_data (module)@\spxentry{util.load\_data}\spxextra{module}}
Convert an 2D or 3D image from polar or cylindrical coordinate to the
cartesian coordinate.
\index{im\_fix\_width() (in module util.load\_data)@\spxentry{im\_fix\_width()}\spxextra{in module util.load\_data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_data.im_fix_width}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_data.}}\sphinxbfcode{\sphinxupquote{im\_fix\_width}}}{\emph{im}, \emph{w}}{}
pad or crop the 3D image to have width and length equal to the input width in Cartesian coordinate system.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} input image

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{w}} \textendash{} output width size

\end{itemize}

\item[{Returns}] \leavevmode
image with the \sphinxtitleref{w} width and length

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_train\_data() (in module util.load\_data)@\spxentry{load\_train\_data()}\spxextra{in module util.load\_data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_data.load_train_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_data.}}\sphinxbfcode{\sphinxupquote{load\_train\_data}}}{\emph{folder\_path}, \emph{im\_shape}, \emph{coord\_sys}}{}
loading the training data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{folder\_path}} \textendash{} the input folder path containing the data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im\_shape}} \textendash{} shape of the images in the dataset in (depth,width,length,channel) format

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_sys}} \textendash{} coordinate system (\sphinxtitleref{polar} or \sphinxtitleref{carts})

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{im}: image tensor of dataset with first row is sample ID

\item {} 
\sphinxstylestrong{label}: label tensor similar to \sphinxtitleref{im}

\item {} 
\sphinxstylestrong{train\_data\_id}: row IDs of training samples

\item {} 
\sphinxstylestrong{test\_data\_id}: row IDs of testing samples

\item {} 
\sphinxstylestrong{valid\_data\_id}: row IDs of validation samples

\item {} 
\sphinxstylestrong{sample\_caseID}: caseID of each row

\end{itemize}


\end{description}\end{quote}


\sphinxstrong{See also:}


{\hyperref[\detokenize{index:util.load_data.make_dataset}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{make\_dataset()}}}}}



\end{fulllineitems}

\index{make\_dataset() (in module util.load\_data)@\spxentry{make\_dataset()}\spxextra{in module util.load\_data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_data.make_dataset}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_data.}}\sphinxbfcode{\sphinxupquote{make\_dataset}}}{\emph{folder\_path}, \emph{im\_shape}, \emph{coord\_sys}, \emph{carts\_w=512}}{}
Produce dataset based oon the results of {\hyperref[\detokenize{index:module-util.process_oct_folder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{util.process\_oct\_folder()}}}}}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{folder\_path}} \textendash{} the path to the folder that contains the images

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im\_shape}} \textendash{} shape of the images in the dataset in (depth,width,length,channel) format

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_sys}} \textendash{} coordinate system (\sphinxtitleref{polar} or \sphinxtitleref{carts})

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{carts\_w}} \textendash{} width of the image in case \sphinxtitleref{coord\_sys == carts}

\end{itemize}

\item[{Returns}] \leavevmode
image and label as the 4D or 5D tensors.  sample\_caseID contains the case ID for each row of image and label

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:module-util.process_oct_folder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{util.process\_oct\_folder()}}}}}

\end{itemize}



\end{fulllineitems}



\section{plot log file}
\label{\detokenize{index:module-util.plot_log_file}}\label{\detokenize{index:plot-log-file}}\index{util.plot\_log\_file (module)@\spxentry{util.plot\_log\_file}\spxextra{module}}
plot the log file within the save model folder. 111

plots the train and validation loss values over last 100 recorded performance evaluations and update the
plot every 5 second.  The figure has two subplots: top one has all the results and bottom one has last 100 log
records.
\subsubsection*{Notes}

Arguments are bash arguments.
\begin{quote}\begin{description}
\item[{param exp\_def}] \leavevmode
the experiment definition used for saving the model.

\item[{param models\_path}] \leavevmode
the path that model folder for \sphinxtitleref{exp\_def}

\item[{returns}] \leavevmode
PyPlot figure with two subplots.

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{train()}}

\end{itemize}




\section{polar to cartesian}
\label{\detokenize{index:module-util.polar2cartesian}}\label{\detokenize{index:polar-to-cartesian}}\index{util.polar2cartesian (module)@\spxentry{util.polar2cartesian}\spxextra{module}}
Convert an 2D or 3D image from polar or cylindrical coordinate to the
cartesian coordinate.
\index{polar2cartesian() (in module util.polar2cartesian)@\spxentry{polar2cartesian()}\spxextra{in module util.polar2cartesian}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.polar2cartesian.polar2cartesian}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.polar2cartesian.}}\sphinxbfcode{\sphinxupquote{polar2cartesian}}}{\emph{im}, \emph{r0=0}, \emph{full=True}, \emph{deg=1}, \emph{scale=1}}{}
Convert the input image from polar to \sphinxstyleemphasis{Cartesian} coordinate system.

A rectangle image in the Polar coordinate system is a circle in the Cartesian coordinate system.  The output
rectangle frame can inscribe the circle or be inscribed by the circle.  The Radius dimension is along the rows and
the zero radius can be the first row or can be a any other row, which crop the rows above that zero-radius row.
The final image can be scale by a factor and the interpolation can be done in zero or one order.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} input polar 2D or 3D image. The 3D is in cylindrical coordinate system.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{r0}} \textendash{} the row index of zero radius. The rows with lower index will be removed.  Default is 0.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{full}} \textendash{} True if the output boundary inscribes the resulted circular boundary or be inscribed by the circular
boundary.  Default is True.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{deg}} \textendash{} degree of interpolation.  0 for nearest neighbor and 1 for linear interpolation.  Default is 1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale}} \textendash{} the scaling ratio of the final result.  Default is 1.

\end{itemize}

\item[{Returns}] \leavevmode
The converted version of im in Cartesian coordinate system.  The final size depends on all the arguments.

\end{description}\end{quote}

\end{fulllineitems}

\index{polar2cartesian\_large\_3d\_file() (in module util.polar2cartesian)@\spxentry{polar2cartesian\_large\_3d\_file()}\spxextra{in module util.polar2cartesian}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.polar2cartesian.polar2cartesian_large_3d_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.polar2cartesian.}}\sphinxbfcode{\sphinxupquote{polar2cartesian\_large\_3d\_file}}}{\emph{im}, \emph{r0=0}, \emph{full=True}, \emph{deg=1}, \emph{scale=1}}{}
polar to Cartesian conversion for big files.

Similar to {\hyperref[\detokenize{index:util.polar2cartesian.polar2cartesian}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{polar2cartesian()}}}}} but convert chunk by chunk to handle very large images.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} input polar 2D or 3D image. The 3D is in cylindrical coordinate system.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{r0}} \textendash{} the row index of zero radius. The rows with lower index will be removed.  Default is 0.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{full}} \textendash{} True if the output boundary inscribes the resulted circular boundary or be inscribed by the circular
boundary.  Default is True.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{deg}} \textendash{} degree of interpolation.  0 for nearest neighbor and 1 for linear interpolation.  Default is 1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale}} \textendash{} the scaling ratio of the final result.  Default is 1.

\end{itemize}

\item[{Returns}] \leavevmode
The converted version of im in Cartesian coordinate system.  The final size depends on all the arguments.

\end{description}\end{quote}

\end{fulllineitems}



\section{process oct folder}
\label{\detokenize{index:module-util.process_oct_folder}}\label{\detokenize{index:process-oct-folder}}\index{util.process\_oct\_folder (module)@\spxentry{util.process\_oct\_folder}\spxextra{module}}
process OCT folder to generate the segmentation labels of cases. Each case has all these three files
\begin{itemize}
\item {} 
* .PSTIF

\item {} 
* .INI

\item {} 
* ROI.txt

\end{itemize}
\index{process\_oct\_folder() (in module util.process\_oct\_folder)@\spxentry{process\_oct\_folder()}\spxextra{in module util.process\_oct\_folder}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.process_oct_folder.process_oct_folder}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.process\_oct\_folder.}}\sphinxbfcode{\sphinxupquote{process\_oct\_folder}}}{\emph{folder\_path}, \emph{scale=0.25}}{}
process OCT folder to generate the segmentation labels of cases.

The \sphinxstyleemphasis{Cartesian} output file can be scale.  Each case should have all these three files
\begin{itemize}
\item {} 
* .PSTIF

\item {} 
* .INI

\item {} 
* ROI.txt

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{folder\_path}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode

It saves three files in the \sphinxtitleref{folder\_path} for each case with a suffix:
\begin{itemize}
\item {} 
\sphinxstylestrong{-im.tif}: the image in cartesian, possibly scaled.

\item {} 
\sphinxstylestrong{-SegP.tif}: The segmentation results in polar coordinate system.

\item {} 
\sphinxstylestrong{-SegP.tif}: The segmentation results in \sphinxstyleemphasis{Cartesian} coordinate system.

\end{itemize}


\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.polar2cartesian.polar2cartesian_large_3d_file}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{util.polar2cartesian.polar2cartesian\_large\_3d\_file()}}}}}

\item {} 
{\hyperref[\detokenize{index:util.read_oct_roi_file.read_oct_roi_file}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{util.read\_oct\_roi\_file.read\_oct\_roi\_file()}}}}}

\end{itemize}



\end{fulllineitems}



\section{read oct roi file}
\label{\detokenize{index:module-util.read_oct_roi_file}}\label{\detokenize{index:read-oct-roi-file}}\index{util.read\_oct\_roi\_file (module)@\spxentry{util.read\_oct\_roi\_file}\spxextra{module}}
Read ROI file generated based on the and generate segmentation results.
\index{lumen\_iel\_mask() (in module util.read\_oct\_roi\_file)@\spxentry{lumen\_iel\_mask()}\spxextra{in module util.read\_oct\_roi\_file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.read_oct_roi_file.lumen_iel_mask}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.read\_oct\_roi\_file.}}\sphinxbfcode{\sphinxupquote{lumen\_iel\_mask}}}{\emph{obj\_list}, \emph{im\_shape}}{}
generate lumen or IEL mask based on the point list.

Based on the periodic nature of polar coordinate system, the boundary within {[}0, 2 pi{]} is copied to {[}- 2 pi, 0{]} and
{[}2 pi, 4 pi{]}. The interpolation happened along the path for x and y independently. Number of points interpolated
between each two consecutive points is based on the largest arc length between all pairs of consecutive points
measured in the cartesian coordinate system.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obj\_list}} \textendash{} list of a single boundary in a single plane

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im\_shape}} \textendash{} the original image shape

\end{itemize}

\item[{Returns}] \leavevmode
A mask image based on the \sphinxtitleref{obj\_list} and size of \sphinxtitleref{im\_obj\_list}.

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.read_oct_roi_file.read_oct_roi_file}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{read\_oct\_roi\_file()}}}}}

\end{itemize}



\end{fulllineitems}

\index{read\_oct\_roi\_file() (in module util.read\_oct\_roi\_file)@\spxentry{read\_oct\_roi\_file()}\spxextra{in module util.read\_oct\_roi\_file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.read_oct_roi_file.read_oct_roi_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.read\_oct\_roi\_file.}}\sphinxbfcode{\sphinxupquote{read\_oct\_roi\_file}}}{\emph{file\_path}, \emph{im\_shape}}{}
generate a label tensor based on a \sphinxtitleref{*ROI.txt} file.  The label tensor is a 8-bit integer, which each bit
encode one the classes:
\begin{itemize}
\item {} 
bit 1 (2**0) encode \sphinxtitleref{gw} (Guide Wire, where guide wire has shadow)

\item {} 
bit 2 (2**1) encode \sphinxtitleref{noniel} (NonIEL, where IEL is not visible)

\item {} 
bit 2  (2**2) encode \sphinxtitleref{lumen} area

\item {} 
bit 3  (2**3) encode \sphinxtitleref{iel} area (the correct term is \sphinxstyleemphasis{intima} layer), which is the between \sphinxtitleref{lumen} and \sphinxtitleref{iel}
boundaries.

\item {} 
other bits are not utilized and can be used for other classes in future.

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_path}} \textendash{} file path to \sphinxtitleref{*ROI.txt} file for a case

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im\_shape}} \textendash{} the output image shape.

\end{itemize}

\item[{Returns}] \leavevmode
the output label image

\item[{Return type}] \leavevmode
uint8

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.read_oct_roi_file.lumen_iel_mask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lumen\_iel\_mask()}}}}}

\item {} 
{\hyperref[\detokenize{index:util.read_oct_roi_file.roi_file_parser}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{roi\_file\_parser()}}}}}

\end{itemize}



\end{fulllineitems}

\index{roi\_file\_parser() (in module util.read\_oct\_roi\_file)@\spxentry{roi\_file\_parser()}\spxextra{in module util.read\_oct\_roi\_file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.read_oct_roi_file.roi_file_parser}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.read\_oct\_roi\_file.}}\sphinxbfcode{\sphinxupquote{roi\_file\_parser}}}{\emph{file\_path}}{}
Parse roi file and output the lists of objects.

The object list is a dictionary that has a list for each keys.  Each class of object has a key.  Keys are:
\begin{itemize}
\item {} 
\sphinxstylestrong{lumen}: vessel lumen boundary

\item {} 
\sphinxstylestrong{iel}: IEL boundary

\item {} 
\sphinxstylestrong{gw}: guide wire arc defined by three points.

\item {} 
\sphinxstylestrong{noniel}: None IEL arc, which is the places that IEL is not visible, defined by three points

\end{itemize}

Each key’s value is a nested list, which first index represents a complete boundary or an arc whitin a plane.
The second index represents a point within the boundary or arc.  The third index represnets the x, y, z
coordinates of the point.
\subsubsection*{Notes}
\begin{description}
\item[{In \sphinxtitleref{*ROI.txt} files:}] \leavevmode\begin{itemize}
\item {} 
Each file has a header line as \sphinxstyleemphasis{ROIformat}.

\item {} 
The first record of a boundary or an arc section has a final field that contain the classification label.

\item {} 
Each boundary record section finishes with the keyword \sphinxstyleemphasis{closed}.

\item {} 
Boundary records start with keyword \sphinxstyleemphasis{Snake}.

\item {} 
Arc records start with keyword \sphinxstyleemphasis{Angle}.

\item {} \begin{description}
\item[{Lumen class can have one of the following classification labels:}] \leavevmode\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstyleemphasis{lumen}

\item {} 
\sphinxstyleemphasis{fibro-fatty}

\item {} 
\sphinxstyleemphasis{fibrous}

\item {} 
\sphinxstyleemphasis{fc}

\item {} 
\sphinxstyleemphasis{fibrous}

\item {} 
\sphinxstyleemphasis{fa}

\item {} 
\sphinxstyleemphasis{normal}

\end{enumerate}

\end{description}

\item {} 
There are some classifications that are ignore in this function such as \sphinxstyleemphasis{calcification}

\end{itemize}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{file\_path}} \textendash{} the path to \sphinxtitleref{*ROI.txt} file

\item[{Returns}] \leavevmode
The object\_list dictionary.

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.read_oct_roi_file.read_oct_roi_file}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{read\_oct\_roi\_file()}}}}}

\end{itemize}



\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{u}
\item\relax\sphinxstyleindexentry{unet.loss}\sphinxstyleindexpageref{index:\detokenize{module-unet.loss}}
\item\relax\sphinxstyleindexentry{unet.ops}\sphinxstyleindexpageref{index:\detokenize{module-unet.ops}}
\item\relax\sphinxstyleindexentry{unet.unet}\sphinxstyleindexpageref{index:\detokenize{module-unet.unet}}
\item\relax\sphinxstyleindexentry{util.confusion\_matrix}\sphinxstyleindexpageref{index:\detokenize{module-util.confusion_matrix}}
\item\relax\sphinxstyleindexentry{util.load\_batch}\sphinxstyleindexpageref{index:\detokenize{module-util.load_batch}}
\item\relax\sphinxstyleindexentry{util.load\_data}\sphinxstyleindexpageref{index:\detokenize{module-util.load_data}}
\item\relax\sphinxstyleindexentry{util.plot\_log\_file}\sphinxstyleindexpageref{index:\detokenize{module-util.plot_log_file}}
\item\relax\sphinxstyleindexentry{util.polar2cartesian}\sphinxstyleindexpageref{index:\detokenize{module-util.polar2cartesian}}
\item\relax\sphinxstyleindexentry{util.process\_oct\_folder}\sphinxstyleindexpageref{index:\detokenize{module-util.process_oct_folder}}
\item\relax\sphinxstyleindexentry{util.read\_oct\_roi\_file}\sphinxstyleindexpageref{index:\detokenize{module-util.read_oct_roi_file}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}