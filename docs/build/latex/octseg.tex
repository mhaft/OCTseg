%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{OCTseg}
\date{Aug 13, 2019}
\release{}
\author{Mohammad Haft-Javaherian}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\chapter{Training and Testing}
\label{\detokenize{index:training-and-testing}}

\chapter{U-Net}
\label{\detokenize{index:u-net}}

\section{loss}
\label{\detokenize{index:module-unet.loss}}\label{\detokenize{index:loss}}\index{unet.loss (module)@\spxentry{unet.loss}\spxextra{module}}
CNN related loss functions
\index{dice\_loss() (in module unet.loss)@\spxentry{dice\_loss()}\spxextra{in module unet.loss}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.loss.dice_loss}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.loss.}}\sphinxbfcode{\sphinxupquote{dice\_loss}}}{\emph{label}, \emph{target}}{}
Soft Dice coefficient loss

TP, FP, and FN are true positive, false positive, and false negative.
\begin{equation*}
\begin{split}dice  &=  \frac{2 \times TP}{ 2 \times TP + FN + FP} \\
dice  &=  \frac{2 \times TP}{(TP + FN) + (TP + FP)}\end{split}
\end{equation*}
objective is to maximize the dice, thus the loss is negate of dice for numerical stability (+1 in denominator)
and fixing the loss range (+1 in numerator and +1 to the negated dice).

The final Dice loss is formulated as
\begin{equation*}
\begin{split}dice \ loss = 1 - \frac{2 \times TP + 1}{(TP + FN) + (TP + FP ) + 1}\end{split}
\end{equation*}
it is soft as each components of the confusion matrix (TP, FP, and FN) are estimated by dot product of
probability instead of hard classification
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} \textendash{} 4D or 5D label tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} \textendash{} 4D or 5d target tensor

\end{itemize}

\item[{Returns}] \leavevmode
dice loss

\end{description}\end{quote}

\end{fulllineitems}

\index{multi\_loss\_fun() (in module unet.loss)@\spxentry{multi\_loss\_fun()}\spxextra{in module unet.loss}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.loss.multi_loss_fun}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.loss.}}\sphinxbfcode{\sphinxupquote{multi\_loss\_fun}}}{\emph{loss\_weight}}{}
Semantic loss function based on the weighted cross entropy and dice and wighted by the loss weights in the input
argument
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{loss\_weight}} \textendash{} a list with two weights for weighted cross entropy and dice losses, respectively.

\item[{Returns}] \leavevmode
\begin{description}
\item[{function, which similar to {\hyperref[\detokenize{index:unet.loss.weighted_cross_entropy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{weighted\_cross\_entropy()}}}}} and {\hyperref[\detokenize{index:unet.loss.dice_loss}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dice\_loss()}}}}}}] \leavevmode
has label and target arguments

\end{description}


\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:unet.loss.weighted_cross_entropy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{weighted\_cross\_entropy()}}}}}

\item {} 
{\hyperref[\detokenize{index:unet.loss.dice_loss}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dice\_loss()}}}}}

\end{itemize}



\end{fulllineitems}

\index{weighted\_cross\_entropy() (in module unet.loss)@\spxentry{weighted\_cross\_entropy()}\spxextra{in module unet.loss}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.loss.weighted_cross_entropy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.loss.}}\sphinxbfcode{\sphinxupquote{weighted\_cross\_entropy}}}{\emph{label}, \emph{target}}{}
Weighted cross entropy with foreground pixels having ten times higher weights
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} \textendash{} 4D or 5D label tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} \textendash{} 4D or 5d target tensor

\end{itemize}

\item[{Returns}] \leavevmode
weighted cross entropy value

\end{description}\end{quote}

\end{fulllineitems}



\section{ops}
\label{\detokenize{index:module-unet.ops}}\label{\detokenize{index:ops}}\index{unet.ops (module)@\spxentry{unet.ops}\spxextra{module}}
CNN related operations
\index{MaxPoolingND() (in module unet.ops)@\spxentry{MaxPoolingND()}\spxextra{in module unet.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.ops.MaxPoolingND}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.ops.}}\sphinxbfcode{\sphinxupquote{MaxPoolingND}}}{\emph{x}}{}
Maxpooling in x and y direction for 2D and 3D inputs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} input 4D or 5D tensor

\item[{Returns}] \leavevmode
downscaled of \sphinxtitleref{x} in x and y direction

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:unet.ops.up_conv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{up\_conv()}}}}}

\item {} 
\sphinxcode{\sphinxupquote{keras.layers.MaxPooling2D()}}

\item {} 
\sphinxcode{\sphinxupquote{keras.layers.MaxPooling3D()}}

\end{itemize}



\end{fulllineitems}

\index{accuracy() (in module unet.ops)@\spxentry{accuracy()}\spxextra{in module unet.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.ops.accuracy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.ops.}}\sphinxbfcode{\sphinxupquote{accuracy}}}{\emph{labels}, \emph{logits}}{}
Measure accuracy metrics. The code calculate the prediction based on the input logits. Metrics are:
\begin{itemize}
\item {} 
accuracy: The ratio of correctly labeled voxels to the total number of voxels.

\item {} 
Jaccard Index: ratio of number of foreground voxels in the intersection of \sphinxtitleref{labels} and \sphinxtitleref{logits} divided by
total number of foreground voxels in the union of \sphinxtitleref{labels} and \sphinxtitleref{logits}

\end{itemize}
\begin{equation*}
\begin{split}accuracy &= \frac{1}{N \times M \times L} \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} (
    label_{i,j,k} == predict_{i,j,k}) \\
Jaccard &= \frac{
    \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} (label_{i,j,k} \  \&\& \  predict_{i,j,k})
}{
    \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} (label_{i,j,k} \  \| \  predict_{i,j,k})
}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{labels}} \textendash{} 4D or 5D tensor of labels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{logits}} \textendash{} 4D or 5D tensor of prediction logits.

\end{itemize}

\item[{Returns}] \leavevmode
accuracy and Jaccard Index

\end{description}\end{quote}

\end{fulllineitems}

\index{conv\_layer() (in module unet.ops)@\spxentry{conv\_layer()}\spxextra{in module unet.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.ops.conv_layer}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.ops.}}\sphinxbfcode{\sphinxupquote{conv\_layer}}}{\emph{x}, \emph{ChOut}}{}
Multi-layer convolution operators consists of three convolutions (2D or 3D based on the input shape) followed by
LeakyReLY.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} input 4D or 5D tensor to the layers

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ChOut}} \textendash{} number of features of outputs of all convolutions

\end{itemize}

\item[{Returns}] \leavevmode
output of the final layer with same size as \sphinxtitleref{x}

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{keras.layers.LeakyReLU()}}

\item {} 
\sphinxcode{\sphinxupquote{keras.layers.Conv2D()}}

\item {} 
\sphinxcode{\sphinxupquote{keras.layers.Conv3D()}}

\end{itemize}



\end{fulllineitems}

\index{placeholder\_inputs() (in module unet.ops)@\spxentry{placeholder\_inputs()}\spxextra{in module unet.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.ops.placeholder_inputs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.ops.}}\sphinxbfcode{\sphinxupquote{placeholder\_inputs}}}{\emph{im\_shape}, \emph{outCh}}{}
Generate placeholder variables to represent the input tensors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im\_shape}} \textendash{} shape of the input tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outCh}} \textendash{} number of channels in the output

\end{itemize}

\item[{Returns}] \leavevmode
image and label placeholders

\end{description}\end{quote}

\end{fulllineitems}

\index{up\_conv() (in module unet.ops)@\spxentry{up\_conv()}\spxextra{in module unet.ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.ops.up_conv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.ops.}}\sphinxbfcode{\sphinxupquote{up\_conv}}}{\emph{x}}{}
upscaling of input tensor in x and y direction using transpose convolution in 2D or 3D.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} input 4D or 5D tensor

\item[{Returns}] \leavevmode
unscaled of \sphinxtitleref{x} in x and y direction

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} \begin{quote}\begin{description}
\item[{meth}] \leavevmode
\sphinxtitleref{MaxPoolingND}

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{meth}] \leavevmode
\sphinxtitleref{KL.Conv2DTranspose}

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{meth}] \leavevmode
\sphinxtitleref{KL.Conv3DTranspose}

\end{description}\end{quote}

\end{itemize}



\end{fulllineitems}



\section{unet}
\label{\detokenize{index:module-unet.unet}}\label{\detokenize{index:unet}}\index{unet.unet (module)@\spxentry{unet.unet}\spxextra{module}}
Build U-Net model
\index{unet\_model() (in module unet.unet)@\spxentry{unet\_model()}\spxextra{in module unet.unet}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:unet.unet.unet_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{unet.unet.}}\sphinxbfcode{\sphinxupquote{unet\_model}}}{\emph{im\_shape}, \emph{nFeature=32}, \emph{outCh=2}, \emph{nLayer=3}}{}
Build U-Net model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} input placeholder

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outCh}} \textendash{} number of output channels

\end{itemize}

\item[{Returns}] \leavevmode
keras model

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Utility}
\label{\detokenize{index:utility}}

\section{confusion matrix}
\label{\detokenize{index:module-util.confusion_matrix}}\label{\detokenize{index:confusion-matrix}}\index{util.confusion\_matrix (module)@\spxentry{util.confusion\_matrix}\spxextra{module}}
calculate confusion matrix. Confusion matrix contains
\begin{itemize}
\item {} 
TP: True positive

\item {} 
TN: True negative

\item {} 
FP: False positive

\item {} 
FN: False Negative

\item {} 
TPR: True positive ratio or sensitivity

\item {} 
TNR: True Negative ratio or specificity

\item {} 
Dice Index

\end{itemize}
\begin{equation*}
\begin{split}Dice = \frac{
        2 \times \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} (label_{i,j,k} \  \&\& \  predict_{i,j,k})
    }{
        \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} label_{i,j,k} \ +              \sum_{i \in [[N]],  j \in [[M]],  k \in [[L]]} predict_{i,j,k}
    }\end{split}
\end{equation*}\subsubsection*{Notes}

Arguments are bash arguments.
\begin{quote}\begin{description}
\item[{param exp\_def}] \leavevmode
experiment definition

\item[{param models\_path}] \leavevmode
experiment definition

\item[{param epoch}] \leavevmode
model saved at this epoch

\item[{param useMask}] \leavevmode
use guide wire and nonIEL masks

\item[{returns}] \leavevmode
add a line to the \sphinxtitleref{../model/confusion\_matrix.csv} file, which contains confusion matrix of testing and vali

\end{description}\end{quote}


\section{load batch}
\label{\detokenize{index:module-util.load_batch}}\label{\detokenize{index:load-batch}}\index{util.load\_batch (module)@\spxentry{util.load\_batch}\spxextra{module}}
Load a batch of data.

Creates batches of data randomly in serial or multi-thread parallel fashion.
\index{img\_aug() (in module util.load\_batch)@\spxentry{img\_aug()}\spxextra{in module util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.img_aug}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{img\_aug}}}{\emph{im}, \emph{l}, \emph{coord\_sys}, \emph{p\_lim=0.5}}{}
Image augmentation manager.

Based on the coordinate system (\sphinxstyleemphasis{Polar} vs.  \sphinxstyleemphasis{Cartesian}),  it selects the corresponding method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} input image 4D or 5D tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{l}} \textendash{} input label 4D or 5D tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_sys}} \textendash{} coordinate system.  ‘polar’ or ‘carts’ for Polar and Cartesian,  respectively.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p\_lim}} \textendash{} probability limit for applying each augmentation case.

\end{itemize}

\item[{Returns}] \leavevmode
augmented im and l

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.load_batch.img_aug_carts}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_aug\_carts()}}}}}

\item {} 
{\hyperref[\detokenize{index:util.load_batch.img_aug_polar}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_aug\_polar()}}}}}

\end{itemize}



\end{fulllineitems}

\index{img\_aug\_carts() (in module util.load\_batch)@\spxentry{img\_aug\_carts()}\spxextra{in module util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.img_aug_carts}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{img\_aug\_carts}}}{\emph{image}, \emph{L}, \emph{prob\_lim=0.5}}{}
Data augmentation in Cartesian coordinate system.

Applies different image augmentation procedures:
\begin{quote}
\begin{itemize}
\item {} 
mirroring the image along 45 degree (y=x line)

\item {} 
mirroring the image along the x axis

\item {} 
mirroring the image along the y axis

\item {} 
mirroring the image along the z axis for 3D images

\item {} 
multiple 90 degree rotations

\item {} 
image intensity scaling by multplying the intensity values with close to one scale value

\item {} 
image scaling.  See {\hyperref[\detokenize{index:util.load_batch.img_rand_scale}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_rand\_scale()}}}}}

\end{itemize}

based on the input probability limit probabilistically applies different augmentation cases.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{image}} \textendash{} input image 4D or 5D tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{L}} \textendash{} input label 4D or 5D tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prob\_lim}} \textendash{} probability limit for applying each augmentation case.

\end{itemize}

\item[{Returns}] \leavevmode
augmented image and L

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.load_batch.img_aug}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_aug()}}}}}

\end{itemize}



\end{fulllineitems}

\index{img\_aug\_polar() (in module util.load\_batch)@\spxentry{img\_aug\_polar()}\spxextra{in module util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.img_aug_polar}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{img\_aug\_polar}}}{\emph{image}, \emph{label}, \emph{prob\_lim=0.5}}{}
Data augmentation in Polar coordinate.

Applies different image augmentation procedures:
\begin{itemize}
\item {} 
random rotations

\item {} 
image intensity scaling by multplying the intensity valuse with close to one scale value

\item {} 
image scaling, which randomly crops or add pads and scale the image to the original size

\end{itemize}

based on the input probability limit probabilistically applies different augmentation cases.
\begin{description}
\item[{Args;}] \leavevmode
image: input image 4D or 5D tensor
label: input label 4D or 5D tensor
prob\_lim: probability limit for applying each augmentation case.

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
augmented image and l

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.load_batch.img_aug}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_aug()}}}}}

\end{itemize}



\end{fulllineitems}

\index{img\_rand\_scale() (in module util.load\_batch)@\spxentry{img\_rand\_scale()}\spxextra{in module util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.img_rand_scale}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{img\_rand\_scale}}}{\emph{im}, \emph{scale}, \emph{order}}{}
Scale one image or label batch in Cartesian coordinate system.

scale the image based on the input scale value and interpolation order followed by cropping or padding to
maintain the original image shape.  For interpolation close to the boundaries,  the reflection mode is used.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} 3D or 4D image or label tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale}} \textendash{} scalar scale values for x and y direction

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order}} \textendash{} interpolation order

\end{itemize}

\item[{Returns}] \leavevmode
same size image with the scale image in the center of it.

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_batch() (in module util.load\_batch)@\spxentry{load\_batch()}\spxextra{in module util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.load_batch}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{load\_batch}}}{\emph{im}, \emph{datasetID}, \emph{nBatch}, \emph{label=None}, \emph{isAug=False}, \emph{coord\_sys='carts'}}{}
load a batch of data from im and/or label based on dataset (e.g. test).

This function handel different coordinate system and image augmentation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} 4D or 5D image tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{datasetID}} \textendash{} index of images in im and/or label along the first axis, which belong to this dataset (e.g.  test)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nBatch}} \textendash{} batch size

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} \textendash{} 4D or 5D label tensor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{isAug}} \textendash{} whether to apply data augmentation. See {\hyperref[\detokenize{index:util.load_batch.img_aug}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_aug()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_sys}} \textendash{} coordinate system \{‘polar’ or ‘carts\}

\end{itemize}

\item[{Returns}] \leavevmode
a batch of data as tuple of (image, label)

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.load_batch.load_batch_parallel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{load\_batch\_parallel()}}}}}

\end{itemize}



\end{fulllineitems}

\index{load\_batch\_parallel() (in module util.load\_batch)@\spxentry{load\_batch\_parallel()}\spxextra{in module util.load\_batch}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_batch.load_batch_parallel}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_batch.}}\sphinxbfcode{\sphinxupquote{load\_batch\_parallel}}}{\emph{im}, \emph{datasetID}, \emph{nBatch}, \emph{label=None}, \emph{isAug=False}, \emph{coord\_sys='carts'}}{}
load a batch of data from im and/or label based on dataset (e.g. test) using multi-thread.

This function handel different coordinate system and image augmentation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} 4D or 5D image tensor

\end{description}\end{quote}
\begin{description}
\item[{datasetID: index of images in im and/or label along the first axis, which belong to this dataset (e.g.  test)}] \leavevmode
nBatch: batch size
label: 4D or 5D label tensor
isAug: whether to apply data augmentation. See {\hyperref[\detokenize{index:util.load_batch.img_aug}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{img\_aug()}}}}}
coord\_sys: coordinate system \{‘polar’ or ‘carts\}

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a batch of data as tuple of (image, label)

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:util.load_batch.load_batch}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{load\_batch()}}}}}

\end{itemize}



\end{fulllineitems}



\section{load data}
\label{\detokenize{index:module-util.load_data}}\label{\detokenize{index:load-data}}\index{util.load\_data (module)@\spxentry{util.load\_data}\spxextra{module}}
Convert an 2D or 3D image from polar or cylindrical coordinate to the
cartesian coordinate.
\index{im\_fix\_width() (in module util.load\_data)@\spxentry{im\_fix\_width()}\spxextra{in module util.load\_data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_data.im_fix_width}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_data.}}\sphinxbfcode{\sphinxupquote{im\_fix\_width}}}{\emph{im}, \emph{w}}{}
pad or crop the 3D image to have width and length equal to the input width in Cartesian coordinate system.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} input image

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{w}} \textendash{} output width size

\end{itemize}

\item[{Returns}] \leavevmode
image with the \sphinxtitleref{w} width and length

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_train\_data() (in module util.load\_data)@\spxentry{load\_train\_data()}\spxextra{in module util.load\_data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_data.load_train_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_data.}}\sphinxbfcode{\sphinxupquote{load\_train\_data}}}{\emph{folder\_path}, \emph{im\_shape}, \emph{coord\_sys}}{}
loading the training data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{folder\_path}} \textendash{} the input folder path containing the data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im\_shape}} \textendash{} shape of the images in the dataset in (depth,width,length,channel) format

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_sys}} \textendash{} coordinate system (\sphinxtitleref{polar} or \sphinxtitleref{carts})

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{im}: image tensor of dataset with first row is sample ID,

\item {} 
\sphinxstylestrong{label}: label tensor similar to \sphinxtitleref{im},

\item {} 
\sphinxstylestrong{train\_data\_id}: row IDs of training samples,

\item {} 
\sphinxstylestrong{test\_data\_id}: row IDs of testing samples,

\item {} 
\sphinxstylestrong{valid\_data\_id}: row IDs of validation samples,

\item {} 
\sphinxstylestrong{sample\_caseID}: caseID of each row,

\end{itemize}


\end{description}\end{quote}


\sphinxstrong{See also:}


{\hyperref[\detokenize{index:util.load_data.make_dataset}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{make\_dataset()}}}}}



\end{fulllineitems}

\index{make\_dataset() (in module util.load\_data)@\spxentry{make\_dataset()}\spxextra{in module util.load\_data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.load_data.make_dataset}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.load\_data.}}\sphinxbfcode{\sphinxupquote{make\_dataset}}}{\emph{folder\_path}, \emph{im\_shape}, \emph{coord\_sys}, \emph{carts\_w=512}}{}
Produce dataset based oon the results of {\hyperref[\detokenize{index:module-util.process_oct_folder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{util.process\_oct\_folder()}}}}}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{folder\_path}} \textendash{} the path to the folder that contains the images

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im\_shape}} \textendash{} shape of the images in the dataset in (depth,width,length,channel) format

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_sys}} \textendash{} coordinate system (\sphinxtitleref{polar} or \sphinxtitleref{carts})

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{carts\_w}} \textendash{} width of the image in case \sphinxtitleref{coord\_sys == carts}

\end{itemize}

\item[{Returns}] \leavevmode
image and label as the 4D or 5D tensors.  sample\_caseID contains the case ID for each row of image and label

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:module-util.process_oct_folder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{util.process\_oct\_folder()}}}}}

\end{itemize}



\end{fulllineitems}



\section{plot log file}
\label{\detokenize{index:module-util.plot_log_file}}\label{\detokenize{index:plot-log-file}}\index{util.plot\_log\_file (module)@\spxentry{util.plot\_log\_file}\spxextra{module}}
plot the log file within the save model folder. 111

plots the train and validation loss values over last 100 recorded performance evaluations and update the
plot every 5 second.  The figure has two subplots: top one has all the results and bottom one has last 100 log
records.
\subsubsection*{Notes}

Arguments are bash arguments.
\begin{quote}\begin{description}
\item[{param exp\_def}] \leavevmode
the experiment definition used for saving the model.

\item[{param models\_path}] \leavevmode
the path that model folder for \sphinxtitleref{exp\_def}

\item[{returns}] \leavevmode
PyPlot figure with two subplots.

\end{description}\end{quote}


\sphinxstrong{See also:}

\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{train()}}

\end{itemize}




\section{polar to cartesian}
\label{\detokenize{index:module-util.polar2cartesian}}\label{\detokenize{index:polar-to-cartesian}}\index{util.polar2cartesian (module)@\spxentry{util.polar2cartesian}\spxextra{module}}
Convert an 2D or 3D image from polar or cylindrical coordinate to the
cartesian coordinate.


\section{process oct folder}
\label{\detokenize{index:module-util.process_oct_folder}}\label{\detokenize{index:process-oct-folder}}\index{util.process\_oct\_folder (module)@\spxentry{util.process\_oct\_folder}\spxextra{module}}
process OCT folder to generate the segmentation labels of cases. Each case all three -.PSTIF, -.INI, and -ROI.txt
files


\section{read oct roi file}
\label{\detokenize{index:module-util.read_oct_roi_file}}\label{\detokenize{index:read-oct-roi-file}}\index{util.read\_oct\_roi\_file (module)@\spxentry{util.read\_oct\_roi\_file}\spxextra{module}}
Read ROI file generated based on the and generate segmentation results.
\index{lumen\_iel\_mask() (in module util.read\_oct\_roi\_file)@\spxentry{lumen\_iel\_mask()}\spxextra{in module util.read\_oct\_roi\_file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.read_oct_roi_file.lumen_iel_mask}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.read\_oct\_roi\_file.}}\sphinxbfcode{\sphinxupquote{lumen\_iel\_mask}}}{\emph{obj\_list}, \emph{im\_shape}}{}
generate lumen or IEL mask based on the point list.

\end{fulllineitems}

\index{roi\_file\_parser() (in module util.read\_oct\_roi\_file)@\spxentry{roi\_file\_parser()}\spxextra{in module util.read\_oct\_roi\_file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:util.read_oct_roi_file.roi_file_parser}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{util.read\_oct\_roi\_file.}}\sphinxbfcode{\sphinxupquote{roi\_file\_parser}}}{\emph{file\_path}}{}
Parse roi file and output the lists of objects

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{u}
\item\relax\sphinxstyleindexentry{unet.loss}\sphinxstyleindexpageref{index:\detokenize{module-unet.loss}}
\item\relax\sphinxstyleindexentry{unet.ops}\sphinxstyleindexpageref{index:\detokenize{module-unet.ops}}
\item\relax\sphinxstyleindexentry{unet.unet}\sphinxstyleindexpageref{index:\detokenize{module-unet.unet}}
\item\relax\sphinxstyleindexentry{util.confusion\_matrix}\sphinxstyleindexpageref{index:\detokenize{module-util.confusion_matrix}}
\item\relax\sphinxstyleindexentry{util.load\_batch}\sphinxstyleindexpageref{index:\detokenize{module-util.load_batch}}
\item\relax\sphinxstyleindexentry{util.load\_data}\sphinxstyleindexpageref{index:\detokenize{module-util.load_data}}
\item\relax\sphinxstyleindexentry{util.plot\_log\_file}\sphinxstyleindexpageref{index:\detokenize{module-util.plot_log_file}}
\item\relax\sphinxstyleindexentry{util.polar2cartesian}\sphinxstyleindexpageref{index:\detokenize{module-util.polar2cartesian}}
\item\relax\sphinxstyleindexentry{util.process\_oct\_folder}\sphinxstyleindexpageref{index:\detokenize{module-util.process_oct_folder}}
\item\relax\sphinxstyleindexentry{util.read\_oct\_roi\_file}\sphinxstyleindexpageref{index:\detokenize{module-util.read_oct_roi_file}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}